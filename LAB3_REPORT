Thinking3.1   
在构造空闲的进程控制块链表时，采用了逆序添加进程控制块到env_free_list的方法。
包括page_free_list在内，这两个队列所采用的的数据结构都是尾队列。    
尾队列是一种比较复杂的数据结构，简单理解它与普通队列的区别在于普通队列的头指针一直指向队列的头部，而尾队列的头指针一直指向队列的尾部。    
这样的话，按照逆序向env_free_list添加空闲的进程控制块，每当创建进程时，env_alloc从队列的头部取出一个空闲的进程控制块。则创建进程使用进程控制块时是正序使用的。    
即如代码注释所言，第一次调用env_alloc使用的是env[0].    
另外一点是，我们实现的简单的轮转算法是从0开始遍历env数组的。按照逆序添加能够保证最先创建的进程能够被最先调度执行。    

Thinking3.2   
(1)
在调用env_alloc创建新进程的过程中，申请到进程控制块后，会调用env_setup_vm函数。    
在这个函数中，会为该进程申请一页作为其页目录，并将相应的地址存放在其进程控制块中。
	for (i = 0; i < PDX(UTOP); i++) {
		pgdir[i] = 0;
	}
这个循环将用户的2G空间(UTOP以下)对应的页目录项初始化为0.     
	for (i = PDX(UTOP); i <= PDX(~0); i++) {
		pgdir[i] = boot_pgdir[i];
	}
这个循环将内核的2G空间对应的页目录项初始化为一个已有的页目录中对应的页目录项。    
按照指导书的解释，MIPS的4G虚拟空间按照2G/2G划分。每一个进程都独享自己的2G用户空间，而每个进程的2G内核空间则共享同一个。   
进程在进入内核态时，并不是切换到了一个新的内核进程，而是通过访问内核虚拟地址即可。而管理内核空间的页表在操作系统启动时已经建立完毕。   
故每个进程都可以在自己的进程内访问内核空间，而这个内核空间对于每个进程而言是相同的，所以为每个进程的页目录拷贝boot_pgdir中相应的页目录项。   
(2)
ULIM是用户空间的最大范围。UTOP可以理解为用户可以修改的最大空间。    
ULIM与UTOP之间有12MB虚拟空间，包括4MB的PAGES，4MB的ENV和4MB的当前进程页表。    
4MB的PAGES空间在操作系统启动时，被映射到了pages数组的物理地址，4MB中多余的页表初始化为0。4MB的ENV空间与启动时的envs数组构成映射关系。   
pages和envs数组都是由操作系统统一管理的。所以，每个进程的这部分地址空间的映射应该与内核空间一样，都由boot_pgdir给出。
(3)
UVPT-ULIM的4MB虚拟空间存储了当前进程的页表。当访问这4MB空间时，其实是在访问该进程的页表，而页表的物理地址存储在页目录中。   
故pgdir[PDX(UVPT)] = ENV_cr3;当访问这4MB空间是，找到的二级页表是页目录本身。

Thinking3.3
user_data在调用mapper函数时传入，而mapper函数则由load_elf调用。在load_elf中调用mapper时，user_data参数传的是load_icode传给load_elf的struct Env *
所以，mapper中的user_data实际上是load_icode函数的参数struct Env * e. 这样，在加载二进制镜像文件时，能够保证都是对同一个进程控制块操作。   
例如：在mapper中申请的物理页面能够保证插入到同一个进程的二级页表中。

Thinking3.4
(1)
指令位置是虚拟地址。即entry_point是一个虚拟地址。entry_point的值在load_elf中被设置为ehdr->e_entry. ehdr是一个struct Elf32_Ehdr类型的指针。   
而load_elf中ehdr是由binary转型得到的。
(2)
一样的。对于每个进程而言，虽然entry_point是一样的，但其映射到的物理地址是不同的，且物理地址存放的内容也是不同的。
(3)
应该存放在UTEXT处。根据这个地址段的字面意思大致可以推测是用来存放进程的代码段和数据段等。对于每一个进程而言，这4G地址空间是相同的，
这也从另一方面印证了对于每个进程而言，其entry_point是相同的。每个进程的代码段都存放在相同的虚拟地址处。
另外，entry_point的值并不是严格从UTEXT开始的。通过打印发现，entry_point的值为0x004000b0。查阅资料得知，elf文件并不是一开始就是代码，
而是有一些struct Elf32_Ehdr中的成员信息。故起始地址为0x004000b0

Thinking3.5
pc的值应设为cp0_epc的值。根据计算机组成的知识，若当前有进程正在执行，而此时发生时钟中断，则处理器会将异常返回后的指令地址存放在cp0的epc寄存器中。
所以cp0_epc中存储的是异常处理结束后进程应该继续执行的指令地址，即该进程再次被调度执行时，应该从epc中保存的指令地址开始执行。所以pc的值设为cp0_epc。

Thinking3.6
(1)
TIMESTACK用于存储发生时钟中断时进程的上下文现场。
(2)
在处理中断的函数中，会调用stackframe.h中的get_sp宏，这个宏的作用就是判断cp0中CP0_CAUSE寄存器所存储的中断产生原因。    
若中断是由时钟中断产生的，则会将sp的值赋为0x82000000，这个值在mmu.h中被定义为TIMESTACK的值    
若中断不是由时钟中断产生，则sp的值被赋为KERNEL_SP。    
故发生时钟中断时，进程的上下文信息会被保存在TIMESTACK所对应的内存中。   
(3)
TIMESTACK和KERNEL_SP的区别主要就在于处理不同的中断时，进程上下文保存的位置不同。   
若中断由时钟中断产生，则进程上下文保存在TIMESTACK；
否则因为其他原因而进入内核态时，进程上下文保存在KERNEL_SP   

Thinking3.7   


Thinking3.7
